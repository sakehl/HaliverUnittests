
/* MACHINE GENERATED By Halide. */

#include <assert.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#ifndef HALIVER_GLOBALS
#define HALIVER_GLOBALS

struct halide_dimension_t {
    int32_t min, extent, stride;
    uint32_t flags;
};

inline void halide_unused(bool e){};

/*@
pure int max(int x, int y) = x > y ? x : y;

pure int min(int x, int y) = x > y ? y : x;

pure float max(float x, float y) = x > y ? x : y;

pure float min(float x, float y) = x > y ? y : x;

pure int abs(int x) = x >= 0 ? x : -x;

pure float abs(float x) = x >= 0 ? x : -x;

// Euclidean division is defined internally in VerCors
inline pure int hdiv(int x, int y) = y == 0 ? 0 : \euclidean_div(x, y);
inline pure int hmod(int x, int y) = y == 0 ? 0 : \euclidean_mod(x, y);
@*/

/*@
  requires y != 0;
  ensures \result == \euclidean_div(x, y);
@*/
/*@ pure @*/ int div_eucl(int x, int y)
{
    int q = x/y;
    int r = x%y;
    return r < 0 ? q + (y > 0 ? -1 : 1) : q;
}

/*@
  requires y != 0;
  ensures \result == \euclidean_mod(x, y);
@*/
/*@ pure @*/ int mod_eucl(int x, int y)
{
    int r = x%y;
    return (x >= 0 || r == 0) ? r : r + abs(y);
}

static inline /*@ pure @*/ int min(int x, int y) {return x < y ? x : y;}
static inline /*@ pure @*/ float fast_inverse_f32(float x) {return 1.0f/x;}

static inline /*@ pure @*/ float sqrt_f32(float x) {return sqrtf(x);}
static inline /*@ pure @*/ float sin_f32(float x) {return sinf(x);}
static inline /*@ pure @*/ float asin_f32(float x) {return asinf(x);}
static inline /*@ pure @*/ float cos_f32(float x) {return cosf(x);}
static inline /*@ pure @*/ float acos_f32(float x) {return acosf(x);}
static inline /*@ pure @*/ float tan_f32(float x) {return tanf(x);}
static inline /*@ pure @*/ float atan_f32(float x) {return atanf(x);}
static inline /*@ pure @*/ float atan2_f32(float x, float y) {return atan2f(x, y);}
static inline /*@ pure @*/ float sinh_f32(float x) {return sinhf(x);}
static inline /*@ pure @*/ float cosh_f32(float x) {return coshf(x);}
static inline /*@ pure @*/ float tanh_f32(float x) {return tanhf(x);}
static inline /*@ pure @*/ float hypot_f32(float x, float y) {return hypotf(x, y);}
static inline /*@ pure @*/ float exp_f32(float x) {return expf(x);}
static inline /*@ pure @*/ float log_f32(float x) {return logf(x);}
static inline /*@ pure @*/ float pow_f32(float x, float y) {return powf(x, y);}
static inline /*@ pure @*/ float floor_f32(float x) {return floorf(x);}
static inline /*@ pure @*/ float ceil_f32(float x) {return ceilf(x);}
static inline /*@ pure @*/ float round_f32(float x) {return roundf(x);}

static inline /*@ pure @*/ double sqrt_f64(double x) {return sqrt(x);}
static inline /*@ pure @*/ double sin_f64(double x) {return sin(x);}
static inline /*@ pure @*/ double asin_f64(double x) {return asin(x);}
static inline /*@ pure @*/ double cos_f64(double x) {return cos(x);}
static inline /*@ pure @*/ double acos_f64(double x) {return acos(x);}
static inline /*@ pure @*/ double tan_f64(double x) {return tan(x);}
static inline /*@ pure @*/ double atan_f64(double x) {return atan(x);}
static inline /*@ pure @*/ double atan2_f64(double x, double y) {return atan2(x, y);}
static inline /*@ pure @*/ double sinh_f64(double x) {return sinh(x);}
static inline /*@ pure @*/ double cosh_f64(double x) {return cosh(x);}
static inline /*@ pure @*/ double tanh_f64(double x) {return tanh(x);}
static inline /*@ pure @*/ double hypot_f64(double x, double y) {return hypot(x, y);}
static inline /*@ pure @*/ double exp_f64(double x) {return exp(x);}
static inline /*@ pure @*/ double log_f64(double x) {return log(x);}
static inline /*@ pure @*/ double pow_f64(double x, double y) {return pow(x, y);}
static inline /*@ pure @*/ double floor_f64(double x) {return floor(x);}
static inline /*@ pure @*/ double ceil_f64(double x) {return ceil(x);}
static inline /*@ pure @*/ double round_f64(double x) {return round(x);}

//@ ghost const float NAN;

inline float nan_f32() {return (float)NAN;}

/*@
inline resource dim_perm(struct halide_dimension_t *dim, rational p, int i) = 
 Perm(dim[i], 1\2) **
 Perm(dim[i].min, 1\2) **
 Perm(dim[i].stride, 1\2) **
 Perm(dim[i].extent, 1\2) **
 dim[i].extent > 0
 ;
 
 requires a >= 0;
 requires b > 0;
 requires a < max_a;
 ensures a*b <= (max_a-1)*b;
 ensures \result;
 decreases b;
pure bool lemma_nonlinear(int a, int b, int max_a);// = b>1 ? lemma_nonlinear(a, b-1, max_a) : true;
 
 requires a-min_a >= 0 && a-min_a<extent_a;
 requires stride_a > 0;

 ensures 0 <= (a-min_a)*stride_a;
 ensures (a-min_a)*stride_a <= (extent_a-1)*stride_a;
 ensures \result;
 decreases;
pure bool lemma_1d_access(int a, int min_a, int stride_a, int extent_a);// = lemma_nonlinear(a-min_a, stride_a, extent_a);

 requires a-min_a >= 0 && a-min_a<extent_a;
 requires b-min_b >= 0 && b-min_b<extent_b;
 requires stride_a > 0;
 requires stride_b >= extent_a*stride_a;

 ensures 0 <= (b-min_b)*stride_b;
 ensures 0 <= (a-min_a)*stride_a + (b-min_b)*stride_b;
 ensures (a-min_a)*stride_a + (b-min_b)*stride_b < stride_b*extent_b;
 ensures \result;
 decreases;
pure bool lemma_2d_access(
 int a, int min_a, int stride_a, int extent_a,
 int b, int min_b, int stride_b, int extent_b);// = lemma_nonlinear(a-min_a, stride_a, extent_a) && lemma_nonlinear(b-min_b, stride_b, extent_b);

pure int split(int xi, int xo, int xmin, int factor) = xo*factor + xi +xmin;
@*/
#endif // HALIVER_GLOBALS

// Non linear lemma's
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 ensures 0 <= (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2;
 ensures (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2< stride_x2* extent_x2;
ensures \result;
 decreases;
pure bool lemma_3d_access(
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2
); //=lemma_2d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1) && lemma_nonlinear(x2-min_x2, stride_x2, extent_x2);

 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 ensures 0 <= (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3;
 ensures (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3< stride_x3* extent_x3;
ensures \result;
 decreases;
pure bool lemma_4d_access(
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3
); //=lemma_3d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2) && lemma_nonlinear(x3-min_x3, stride_x3, extent_x3);

 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 ensures 0 <= (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4;
 ensures (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4< stride_x4* extent_x4;
ensures \result;
 decreases;
pure bool lemma_5d_access(
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4
); //=lemma_4d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3) && lemma_nonlinear(x4-min_x4, stride_x4, extent_x4);

 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires x5-min_x5 >= 0 && x5-min_x5 < extent_x5;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 requires stride_x5 >= extent_x4 * stride_x4;
 ensures 0 <= (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5;
 ensures (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5< stride_x5* extent_x5;
ensures \result;
 decreases;
pure bool lemma_6d_access(
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4,
 int x5, int min_x5, int stride_x5, int extent_x5
); //=lemma_5d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3, x4, min_x4, stride_x4, extent_x4) && lemma_nonlinear(x5-min_x5, stride_x5, extent_x5);

 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires x5-min_x5 >= 0 && x5-min_x5 < extent_x5;
 requires x6-min_x6 >= 0 && x6-min_x6 < extent_x6;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 requires stride_x5 >= extent_x4 * stride_x4;
 requires stride_x6 >= extent_x5 * stride_x5;
 ensures 0 <= (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5 + (x6-min_x6) * stride_x6;
 ensures (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5 + (x6-min_x6) * stride_x6< stride_x6* extent_x6;
ensures \result;
 decreases;
pure bool lemma_7d_access(
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4,
 int x5, int min_x5, int stride_x5, int extent_x5,
 int x6, int min_x6, int stride_x6, int extent_x6
); //=lemma_6d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3, x4, min_x4, stride_x4, extent_x4, x5, min_x5, stride_x5, extent_x5) && lemma_nonlinear(x6-min_x6, stride_x6, extent_x6);

 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires x5-min_x5 >= 0 && x5-min_x5 < extent_x5;
 requires x6-min_x6 >= 0 && x6-min_x6 < extent_x6;
 requires x7-min_x7 >= 0 && x7-min_x7 < extent_x7;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 requires stride_x5 >= extent_x4 * stride_x4;
 requires stride_x6 >= extent_x5 * stride_x5;
 requires stride_x7 >= extent_x6 * stride_x6;
 ensures 0 <= (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5 + (x6-min_x6) * stride_x6 + (x7-min_x7) * stride_x7;
 ensures (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5 + (x6-min_x6) * stride_x6 + (x7-min_x7) * stride_x7< stride_x7* extent_x7;
ensures \result;
 decreases;
pure bool lemma_8d_access(
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4,
 int x5, int min_x5, int stride_x5, int extent_x5,
 int x6, int min_x6, int stride_x6, int extent_x6,
 int x7, int min_x7, int stride_x7, int extent_x7
); //=lemma_7d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3, x4, min_x4, stride_x4, extent_x4, x5, min_x5, stride_x5, extent_x5, x6, min_x6, stride_x6, extent_x6) && lemma_nonlinear(x7-min_x7, stride_x7, extent_x7);

 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires x5-min_x5 >= 0 && x5-min_x5 < extent_x5;
 requires x6-min_x6 >= 0 && x6-min_x6 < extent_x6;
 requires x7-min_x7 >= 0 && x7-min_x7 < extent_x7;
 requires x8-min_x8 >= 0 && x8-min_x8 < extent_x8;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 requires stride_x5 >= extent_x4 * stride_x4;
 requires stride_x6 >= extent_x5 * stride_x5;
 requires stride_x7 >= extent_x6 * stride_x6;
 requires stride_x8 >= extent_x7 * stride_x7;
 ensures 0 <= (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5 + (x6-min_x6) * stride_x6 + (x7-min_x7) * stride_x7 + (x8-min_x8) * stride_x8;
 ensures (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5 + (x6-min_x6) * stride_x6 + (x7-min_x7) * stride_x7 + (x8-min_x8) * stride_x8< stride_x8* extent_x8;
ensures \result;
 decreases;
pure bool lemma_9d_access(
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4,
 int x5, int min_x5, int stride_x5, int extent_x5,
 int x6, int min_x6, int stride_x6, int extent_x6,
 int x7, int min_x7, int stride_x7, int extent_x7,
 int x8, int min_x8, int stride_x8, int extent_x8
); //=lemma_8d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3, x4, min_x4, stride_x4, extent_x4, x5, min_x5, stride_x5, extent_x5, x6, min_x6, stride_x6, extent_x6, x7, min_x7, stride_x7, extent_x7) && lemma_nonlinear(x8-min_x8, stride_x8, extent_x8);

@*/
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires stride_x0 > 0;
 requires idx == (x0-min_x0) * stride_x0;
 ensures \result == idx;
 ensures lemma_1d_access(x0, min_x0, stride_x0, extent_x0);
 ensures 0 <= \result;
 ensures \result < stride_x0* extent_x0;
 decreases;
@*/
/*@ pure @*/ int lemma_1d_access_concrete(int idx, 
 int x0, int min_x0, int stride_x0, int extent_x0
){
 return idx;
}
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires idx == (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1;
 ensures \result == idx;
 ensures lemma_2d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1);
 ensures 0 <= \result;
 ensures \result < stride_x1* extent_x1;
 decreases;
@*/
/*@ pure @*/ int lemma_2d_access_concrete(int idx, 
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1
){
 return idx;
}
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires idx == (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2;
 ensures \result == idx;
 ensures lemma_3d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2);
 ensures 0 <= \result;
 ensures \result < stride_x2* extent_x2;
 decreases;
@*/
/*@ pure @*/ int lemma_3d_access_concrete(int idx, 
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2
){
 return idx;
}
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires idx == (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3;
 ensures \result == idx;
 ensures lemma_4d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3);
 ensures 0 <= \result;
 ensures \result < stride_x3* extent_x3;
 decreases;
@*/
/*@ pure @*/ int lemma_4d_access_concrete(int idx, 
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3
){
 return idx;
}
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 requires idx == (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4;
 ensures \result == idx;
 ensures lemma_5d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3, x4, min_x4, stride_x4, extent_x4);
 ensures 0 <= \result;
 ensures \result < stride_x4* extent_x4;
 decreases;
@*/
/*@ pure @*/ int lemma_5d_access_concrete(int idx, 
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4
){
 return idx;
}
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires x5-min_x5 >= 0 && x5-min_x5 < extent_x5;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 requires stride_x5 >= extent_x4 * stride_x4;
 requires idx == (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5;
 ensures \result == idx;
 ensures lemma_6d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3, x4, min_x4, stride_x4, extent_x4, x5, min_x5, stride_x5, extent_x5);
 ensures 0 <= \result;
 ensures \result < stride_x5* extent_x5;
 decreases;
@*/
/*@ pure @*/ int lemma_6d_access_concrete(int idx, 
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4,
 int x5, int min_x5, int stride_x5, int extent_x5
){
 return idx;
}
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires x5-min_x5 >= 0 && x5-min_x5 < extent_x5;
 requires x6-min_x6 >= 0 && x6-min_x6 < extent_x6;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 requires stride_x5 >= extent_x4 * stride_x4;
 requires stride_x6 >= extent_x5 * stride_x5;
 requires idx == (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5 + (x6-min_x6) * stride_x6;
 ensures \result == idx;
 ensures lemma_7d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3, x4, min_x4, stride_x4, extent_x4, x5, min_x5, stride_x5, extent_x5, x6, min_x6, stride_x6, extent_x6);
 ensures 0 <= \result;
 ensures \result < stride_x6* extent_x6;
 decreases;
@*/
/*@ pure @*/ int lemma_7d_access_concrete(int idx, 
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4,
 int x5, int min_x5, int stride_x5, int extent_x5,
 int x6, int min_x6, int stride_x6, int extent_x6
){
 return idx;
}
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires x5-min_x5 >= 0 && x5-min_x5 < extent_x5;
 requires x6-min_x6 >= 0 && x6-min_x6 < extent_x6;
 requires x7-min_x7 >= 0 && x7-min_x7 < extent_x7;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 requires stride_x5 >= extent_x4 * stride_x4;
 requires stride_x6 >= extent_x5 * stride_x5;
 requires stride_x7 >= extent_x6 * stride_x6;
 requires idx == (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5 + (x6-min_x6) * stride_x6 + (x7-min_x7) * stride_x7;
 ensures \result == idx;
 ensures lemma_8d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3, x4, min_x4, stride_x4, extent_x4, x5, min_x5, stride_x5, extent_x5, x6, min_x6, stride_x6, extent_x6, x7, min_x7, stride_x7, extent_x7);
 ensures 0 <= \result;
 ensures \result < stride_x7* extent_x7;
 decreases;
@*/
/*@ pure @*/ int lemma_8d_access_concrete(int idx, 
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4,
 int x5, int min_x5, int stride_x5, int extent_x5,
 int x6, int min_x6, int stride_x6, int extent_x6,
 int x7, int min_x7, int stride_x7, int extent_x7
){
 return idx;
}
/*@
 requires x0-min_x0 >= 0 && x0-min_x0 < extent_x0;
 requires x1-min_x1 >= 0 && x1-min_x1 < extent_x1;
 requires x2-min_x2 >= 0 && x2-min_x2 < extent_x2;
 requires x3-min_x3 >= 0 && x3-min_x3 < extent_x3;
 requires x4-min_x4 >= 0 && x4-min_x4 < extent_x4;
 requires x5-min_x5 >= 0 && x5-min_x5 < extent_x5;
 requires x6-min_x6 >= 0 && x6-min_x6 < extent_x6;
 requires x7-min_x7 >= 0 && x7-min_x7 < extent_x7;
 requires x8-min_x8 >= 0 && x8-min_x8 < extent_x8;
 requires stride_x0 > 0;
 requires stride_x1 >= extent_x0 * stride_x0;
 requires stride_x2 >= extent_x1 * stride_x1;
 requires stride_x3 >= extent_x2 * stride_x2;
 requires stride_x4 >= extent_x3 * stride_x3;
 requires stride_x5 >= extent_x4 * stride_x4;
 requires stride_x6 >= extent_x5 * stride_x5;
 requires stride_x7 >= extent_x6 * stride_x6;
 requires stride_x8 >= extent_x7 * stride_x7;
 requires idx == (x0-min_x0) * stride_x0 + (x1-min_x1) * stride_x1 + (x2-min_x2) * stride_x2 + (x3-min_x3) * stride_x3 + (x4-min_x4) * stride_x4 + (x5-min_x5) * stride_x5 + (x6-min_x6) * stride_x6 + (x7-min_x7) * stride_x7 + (x8-min_x8) * stride_x8;
 ensures \result == idx;
 ensures lemma_9d_access(x0, min_x0, stride_x0, extent_x0, x1, min_x1, stride_x1, extent_x1, x2, min_x2, stride_x2, extent_x2, x3, min_x3, stride_x3, extent_x3, x4, min_x4, stride_x4, extent_x4, x5, min_x5, stride_x5, extent_x5, x6, min_x6, stride_x6, extent_x6, x7, min_x7, stride_x7, extent_x7, x8, min_x8, stride_x8, extent_x8);
 ensures 0 <= \result;
 ensures \result < stride_x8* extent_x8;
 decreases;
@*/
/*@ pure @*/ int lemma_9d_access_concrete(int idx, 
 int x0, int min_x0, int stride_x0, int extent_x0,
 int x1, int min_x1, int stride_x1, int extent_x1,
 int x2, int min_x2, int stride_x2, int extent_x2,
 int x3, int min_x3, int stride_x3, int extent_x3,
 int x4, int min_x4, int stride_x4, int extent_x4,
 int x5, int min_x5, int stride_x5, int extent_x5,
 int x6, int min_x6, int stride_x6, int extent_x6,
 int x7, int min_x7, int stride_x7, int extent_x7,
 int x8, int min_x8, int stride_x8, int extent_x8
){
 return idx;
}
/*@

@*/

#ifndef HALIDE_BUFFER_SHAPE
#define HALIDE_BUFFER_SHAPE
struct halide_shape {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;
};

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(*buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
inline /*@ pure @*/ int _halide_buffer_get_min(struct halide_shape *buf , int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(*buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
inline /*@ pure @*/ int _halide_buffer_get_max(struct halide_shape *buf , int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(*buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
inline /*@ pure @*/ int _halide_buffer_get_extent(struct halide_shape *buf , int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(*buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
inline /*@ pure @*/ int _halide_buffer_get_stride(struct halide_shape *buf , int d) {
    return buf->dim[d].stride;
}
#endif // HALIDE_BUFFER_SHAPE
#ifndef HALIDE_BUFFER_TYPE_CONST_INT32_T
#define HALIDE_BUFFER_TYPE_CONST_INT32_T
struct halide_buffer_const_int32_t {

    /** Contains dimensionality and shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_shape shape;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    const int32_t *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(*buf, 1\2);
 @*/
inline /*@ pure @*/ const int32_t *_halide_buffer_get_host_const_int32_t(struct halide_buffer_const_int32_t *buf) {
    return buf->host;
}

/*@
inline resource buffer_const_int32_t(struct halide_buffer_const_int32_t *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(*buf, p) **
 buf->shape.dim != NULL **
 \pointer_length(buf->shape.dim) == n_dims **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_CONST_INT32_T
#ifndef HALIDE_BUFFER_TYPE_INT32_T
#define HALIDE_BUFFER_TYPE_INT32_T
struct halide_buffer_int32_t {

    /** Contains dimensionality and shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_shape shape;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    /*@unique<0>@*/ int32_t *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(*buf, 1\2);
 @*/
inline /*@ pure @*/ /*@unique<0>@*/ int32_t *_halide_buffer_get_host_int32_t(struct halide_buffer_int32_t *buf) {
    return buf->host;
}

/*@
inline resource buffer_int32_t(struct halide_buffer_int32_t *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(*buf, p) **
 buf->shape.dim != NULL **
 \pointer_length(buf->shape.dim) == n_dims **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_INT32_T

/*@
 decreases n;
 requires n >= 0;
 requires x>=0 && x<42;
 requires inp != NULL ** \pointer_length(inp) >= 42*n;
 ensures |\result| == n;
 ensures (\forall int i; 0 <= i && i < n; {:\result[i]:} == inp[x + 42*i]);
opaque pure seq<int> inp_to_row(int x, int n, const int* inp) = n == 0 ? [t: int ] : inp_to_row(x, n-1, inp) + [inp[x + 42*(n-1)]];

 decreases |xs|;
 ensures |xs| > 0 ==> \result == (xs[0] > 0 ? 1 : 0) + count_row(xs.tail);
pure int count_row(seq<int> xs) = |xs| ==0 ? 0 : (xs[0] > 0 ? 1 : 0) + count_row(xs.tail);
@*/



#ifdef __cplusplus
extern "C" {
#endif

/*@
 context buffer_const_int32_t(_inp_buffer, 1\2, 2);
 context dim_perm(_inp_buffer->shape.dim, 1\2, 0);
 context dim_perm(_inp_buffer->shape.dim, 1\2, 1);
 context \pointer_length(_inp_buffer->host) == _inp_buffer->shape.dim[1].extent * _inp_buffer->shape.dim[1].stride;
 context buffer_int32_t(_count_buffer, 1\2, 1);
 context dim_perm(_count_buffer->shape.dim, 1\2, 0);
 context \pointer_length(_count_buffer->host) == _count_buffer->shape.dim[0].extent * _count_buffer->shape.dim[0].stride;
 context _inp_buffer->shape.dim[0].min == 0 && _inp_buffer->shape.dim[0].extent == 42 && _inp_buffer->shape.dim[0].stride == 1;
 context _inp_buffer->shape.dim[1].min == 0 && _inp_buffer->shape.dim[1].extent == 10 && _inp_buffer->shape.dim[1].stride == 42;
 requires (\forall int _0, int _1; 0 <= _0 && _0 < 42 && 0 <= _1 && _1 < 10; ((_1 < _0) ? (0 < {:_inp_buffer->host[_1*42 + _0]:}) : (_inp_buffer->host[_1*42 + _0] <= 0)));
 context _count_buffer->shape.dim[0].min == 0 && _count_buffer->shape.dim[0].extent == 42 && _count_buffer->shape.dim[0].stride == 1;
 context (\forall* int _0; 0 <= _0 && _0 < 42; Perm({:_count_buffer->host[_0]:}, 1\1));
 ensures (\forall int _0; 0 <= _0 && _0 < 42; 0 <= {:_count_buffer->host[_0]:} && _count_buffer->host[_0] <= 10);
 ensures (\forall int _0; 0 <= _0 && _0 < 42; 0 <= {:_count_buffer->host[_0]:} && _count_buffer->host[_0] <= 10);
 ensures (\forall int x; (0 <= x) && (x < 42); 
    {:_count_buffer->host[x]:} == count_row(inp_to_row(x, 10, _inp_buffer->host)));
@*/
int count(struct halide_buffer_const_int32_t *_inp_buffer, /*@unique_pointer_field<host, 1>@*/ struct halide_buffer_int32_t *_count_buffer) {
 /*@unique<1>@*/ int32_t* _count = _halide_buffer_get_host_int32_t(_count_buffer);
 int32_t _count_min_0 = _halide_buffer_get_min(&_count_buffer->shape, 0);
 int32_t _count_extent_0 = _halide_buffer_get_extent(&_count_buffer->shape, 0);
 int32_t _count_stride_0 = _halide_buffer_get_stride(&_count_buffer->shape, 0);
 const int32_t* _inp = _halide_buffer_get_host_const_int32_t(_inp_buffer);
 int32_t _inp_min_0 = _halide_buffer_get_min(&_inp_buffer->shape, 0);
 int32_t _inp_extent_0 = _halide_buffer_get_extent(&_inp_buffer->shape, 0);
 int32_t _inp_stride_0 = _halide_buffer_get_stride(&_inp_buffer->shape, 0);
 int32_t _inp_min_1 = _halide_buffer_get_min(&_inp_buffer->shape, 1);
 int32_t _inp_extent_1 = _halide_buffer_get_extent(&_inp_buffer->shape, 1);
 int32_t _inp_stride_1 = _halide_buffer_get_stride(&_inp_buffer->shape, 1);
 halide_unused((_count_stride_0 == 1));
 halide_unused((_count_min_0 == 0));
 halide_unused((_count_extent_0 == 42));
 halide_unused((_inp_stride_0 == 1));
 halide_unused((_inp_min_0 == 0));
 halide_unused((_inp_extent_0 == 42));
 halide_unused((_inp_stride_1 == 42));
 halide_unused((_inp_min_1 == 0));
 halide_unused((_inp_extent_1 == 10));
 // produce count
 /*@
  loop_invariant 0 <= _count_s0_x && _count_s0_x <= 0 + 42;
  loop_invariant (\forall* int _count_s0_x_forall; 0 <= _count_s0_x_forall && _count_s0_x_forall < 42; Perm({:_count[_count_s0_x_forall]:}, 1\1));
  loop_invariant (\forall int _count_s0_x_forall; 0 <= _count_s0_x_forall && _count_s0_x_forall < _count_s0_x; {:_count[_count_s0_x_forall]:} == 0);
 @*/
 for (int _count_s0_x = 0; _count_s0_x < 0 + 42; _count_s0_x++)
 {
  _count[_count_s0_x]= 0;
 } // for _count_s0_x
 /*@
  loop_invariant 0 <= _count_s1_x && _count_s1_x <= 0 + 42;
  loop_invariant (\forall* int _count_s1_x_forall; 0 <= _count_s1_x_forall && _count_s1_x_forall < 42; Perm({:_count[_count_s1_x_forall]:}, 1\1));
  loop_invariant (\forall int _count_s1_x_forall; _count_s1_x <= _count_s1_x_forall && _count_s1_x_forall < 42; 0 <= {:_count[_count_s1_x_forall]:} && _count[_count_s1_x_forall] <= 0);
  loop_invariant (\forall int _count_s1_x_forall; 0 <= _count_s1_x_forall && _count_s1_x_forall < _count_s1_x; 0 <= {:_count[_count_s1_x_forall]:} && _count[_count_s1_x_forall] <= 10);
  loop_invariant (\forall int _count_s1_x_forall; _count_s1_x <= _count_s1_x_forall && _count_s1_x_forall < 42; {:_count[_count_s1_x_forall]:} == 0);
  loop_invariant (\forall int _count_s1_x_forall; (0 <= _count_s1_x_forall) && (_count_s1_x_forall < _count_s1_x);
    {:_count[_count_s1_x_forall]:} == count_row(inp_to_row(_count_s1_x_forall, 10, _inp)));
 @*/
 for (int _count_s1_x = 0; _count_s1_x < 0 + 42; _count_s1_x++)
 {
  /*@
   loop_invariant 0 <= _count_s1_r6__x && _count_s1_r6__x <= 0 + 10;
   loop_invariant true;
   loop_invariant Perm({:_count[_count_s1_x]:}, 1\1);
   loop_invariant 0 <= {:_count[_count_s1_x]:} && _count[_count_s1_x] <= _count_s1_r6__x;
   loop_invariant {:_count[_count_s1_x]:} == min(_count_s1_r6__x, _count_s1_x);
   loop_invariant _count[_count_s1_x] == count_row(inp_to_row(_count_s1_x, _count_s1_r6__x, _inp));
  @*/
  for (int _count_s1_r6__x = 0; _count_s1_r6__x < 0 + 10; _count_s1_r6__x++)
  {
   int32_t _6 = _count[_count_s1_x];
   int32_t _7 = _inp[((_count_s1_r6__x * 42) + _count_s1_x)];
   _count[_count_s1_x]= (_6 + ((0 < _7) ? 1 : 0));
  } // for _count_s1_r6__x
 } // for _count_s1_x
 return 0;
}

#ifdef __cplusplus
}  // extern "C"
#endif

