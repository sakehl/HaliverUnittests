domain WellFoundedOrder[T]  {
  
  function bounded(v: T): Bool 
  
  function decreasing(v1: T, v2: T): Bool 
}

domain IntOrder  {
  
  axiom {
    (forall i: Int ::0 <= i == (bounded(i): Bool))
  }
  
  axiom {
    (forall i: Int ::(forall j: Int ::i < j == (decreasing(i, j): Bool)))
  }
}

domain Block  {
  
  function block_length(b: Block): Int 
  
  function loc(b: Block, i: Int): Ref 
  
  function loc_inv_1(r: Ref): Block 
  
  function loc_inv_2(r: Ref): Int 
  
  axiom {
    (forall b: Block ::block_length(b) >= 0)
  }
  
  axiom {
    (forall b: Block, i: Int ::
      { loc(b, i) }
      loc_inv_1(loc(b, i)) == b && loc_inv_2(loc(b, i)) == i)
  }
}

domain Pointer  {
  
  function pointer_of(b: Block, offset: Int): Pointer 
  
  function pointer_block(p: Pointer): Block 
  
  function pointer_offset(p: Pointer): Int 
  
  axiom {
    (forall p: Pointer ::pointer_offset(p) >= 0 &&
      pointer_offset(p) < block_length(pointer_block(p)))
  }
  
  axiom {
    (forall b: Block, offset: Int ::
      { pointer_block(pointer_of(b, offset)), pointer_offset(pointer_of(b, offset)) }
      pointer_block(pointer_of(b, offset)) == b &&
      pointer_offset(pointer_of(b, offset)) == offset)
  }
}

domain Any  {
  
  
}

domain Option[T1]  {
  
  function none1(): Option[T1] 
  
  function some(x: T1): Option[T1] 
  
  function option_get(opt: Option[T1]): T1 
  
  axiom {
    (forall x: T1 ::
      { (some(x): Option[T1]) }
      (none1(): Option[T1]) != (some(x): Option[T1]))
  }
  
  axiom {
    (forall x: T1 ::
      { (some(x): Option[T1]) }
      (option_get((some(x): Option[T1])): T1) == x)
  }
  
  axiom {
    (forall opt: Option[T1] ::
      { (some((option_get(opt): T1)): Option[T1]) }
      (some((option_get(opt): T1)): Option[T1]) == opt)
  }
}

domain Nothing  {
  
  
}

domain Void  {
  
  function unit(): Void 
  
  axiom {
    (forall v: Void ::true ==> unit() == v)
  }
}

field int: Int

function ptrDeref(p: Pointer): Ref
  decreases 
{
  loc(pointer_block(p), pointer_offset(p))
}

function ptrAdd(p: Pointer, offset: Int): Pointer
  requires 0 <= pointer_offset(p) + offset
  requires pointer_offset(p) + offset < block_length(pointer_block(p))
  decreases 
{
  pointer_of(pointer_block(p), pointer_offset(p) + offset)
}

function anyAs(t: Any): Any
  decreases 


function asAny(t: Any): Any
  decreases 
  ensures anyAs(result) == t


function optGet(opt: Option[Any]): Any
  requires opt != (none1(): Option[Any])
  decreases 
  ensures (some(result): Option[Any]) == opt
{
  (option_get(opt): Any)
}

function optOrElse(opt: Option[Any], alt: Any): Any
  decreases 
  ensures opt == (none1(): Option[Any]) ==> result == alt
  ensures opt != (none1(): Option[Any]) ==> result == optGet(opt)
{
  (opt == (none1(): Option[Any]) ? alt : optGet(opt))
}

function nothingAs(value: Nothing): Any
  decreases 


function nothingAs1(value: Nothing): Pointer
  decreases 


function optGet1(opt: Option[Nothing]): Nothing
  requires opt != (none1(): Option[Nothing])
  decreases 
  ensures (some(result): Option[Nothing]) == opt
{
  (option_get(opt): Nothing)
}

function optGet2(opt: Option[Pointer]): Pointer
  requires opt != (none1(): Option[Pointer])
  decreases 
  ensures (some(result): Option[Pointer]) == opt
{
  (option_get(opt): Pointer)
}

function lemma2dAccess(a: Int, minA: Int, strideA: Int, extentA: Int, b: Int,
  minB: Int, strideB: Int, extentB: Int): Bool
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires 0 < strideA
  requires extentA * strideA <= strideB
  decreases 
  ensures 0 <= (b - minB) * strideB
  ensures 0 <= (a - minA) * strideA + (b - minB) * strideB
  ensures (a - minA) * strideA + (b - minB) * strideB < strideB * extentB
  ensures result


function type(type1: Ref): Int
  decreases 
  ensures result >= 0
  ensures result <= 0
  ensures type1 == null ==> result == 0
  ensures type1 != null ==> result != 0


function subtype(subtype1: Int, subtype2: Int): Bool
  requires subtype1 >= 0
  requires subtype1 <= 0
  requires subtype2 >= 0
  requires subtype2 <= 0
  decreases 
{
  (subtype1 == 0 ==> true) && true
}

predicate fPred(data0: Option[Pointer], x: Int, xMin: Int, xExtent: Int, y: Int,
  yMin: Int, yExtent: Int) {
  xMin <= x && x < xMin + xExtent && yMin <= y && y < yMin + yExtent &&
  data0 !=
  ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
    (none1(): Option[Pointer]) :
    (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])) &&
  block_length(pointer_block(optGet2(data0))) -
  pointer_offset(optGet2(data0)) ==
  xExtent * yExtent &&
  lemma2dAccess(x, xMin, 1, xExtent, y, yMin, xExtent, yExtent) &&
  (let idx ==
    (x - xMin + (y - yMin) * xExtent) in
    acc(ptrDeref(optGet2((some(ptrAdd(optGet2(data0), idx)): Option[Pointer]))).int, write))
}

predicate int32Pred(data: Option[Pointer]) {
  data !=
  ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
    (none1(): Option[Pointer]) :
    (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])) &&
  (forall i: Int ::
    { ptrDeref(ptrAdd(optGet2(data), i)).int }
    0 <= i &&
    i <
    block_length(pointer_block(optGet2(data))) -
    pointer_offset(optGet2(data)) ==>
    acc(ptrDeref(optGet2((some(ptrAdd(optGet2(data), i)): Option[Pointer]))).int, write))
}

method toPred(tid: Int, f: Option[Pointer], minx: Int, extentx: Int, miny: Int,
  extenty: Int)
  returns (res: Void)
  requires 0 < extentx
  requires 0 < extenty
  requires f !=
    ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
      (none1(): Option[Pointer]) :
      (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
  requires block_length(pointer_block(optGet2(f))) -
    pointer_offset(optGet2(f)) ==
    extentx * extenty
  requires (forall i: Int ::
      { ptrDeref(ptrAdd(optGet2(f), i)).int }
      0 <= i &&
      i <
      block_length(pointer_block(optGet2(f))) - pointer_offset(optGet2(f)) ==>
      acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), i)): Option[Pointer]))).int, write))
  ensures 0 < extentx
  ensures 0 < extenty
  ensures f !=
    ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
      (none1(): Option[Pointer]) :
      (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
  ensures block_length(pointer_block(optGet2(f))) -
    pointer_offset(optGet2(f)) ==
    extentx * extenty
  ensures (forall x: Int, y: Int ::
      { fPred(f, x, minx, extentx, y, miny, extenty) }
      minx <= x && x < minx + extentx && miny <= y && y < miny + extenty ==>
      acc(fPred(f, x, minx, extentx, y, miny, extenty), write))
{
  {
    var exc: Ref
    var return: Void
    var j: Int
    var i: Int
    var flatten: Int
    var flatten1: Int
    var excbeforeloop: Ref
    var excbeforeloop1: Ref
    exc := null
    label LOOP
    excbeforeloop := exc
    j := miny
    while (j < miny + extenty)
      invariant exc == excbeforeloop
      invariant 0 < extentx
      invariant 0 < extenty
      invariant f !=
        ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
          (none1(): Option[Pointer]) :
          (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
      invariant block_length(pointer_block(optGet2(f))) -
        pointer_offset(optGet2(f)) ==
        extentx * extenty
      invariant miny <= j
      invariant j < miny + extenty + 1
      invariant (forall x_y: Int ::
          { ptrDeref(ptrAdd(optGet2(f), x_y)).int }
          0 <= x_y - (-1 * minx - extentx * miny + minx + extentx * j) &&
          x_y - (-1 * minx - extentx * miny + minx + extentx * j) <
          extentx * (miny + extenty - j) ==>
          acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), x_y)): Option[Pointer]))).int, write))
      invariant (forall x: Int, y: Int ::
          { fPred(f, x, minx, extentx, y, miny, extenty) }
          minx <= x && x < minx + extentx && miny <= y && y < j ==>
          acc(fPred(f, x, minx, extentx, y, miny, extenty), write)) 
    {
      label LOOP1
      excbeforeloop1 := exc
      i := minx
      while (i < minx + extentx)
        invariant exc == excbeforeloop1
        invariant 0 < extentx
        invariant 0 < extenty
        invariant f !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
        invariant block_length(pointer_block(optGet2(f))) -
          pointer_offset(optGet2(f)) ==
          extentx * extenty
        invariant minx <= i
        invariant i < minx + extentx + 1
        invariant (forall x: Int ::
            { ptrDeref(ptrAdd(optGet2(f), x)).int }
            0 <= x - (-1 * minx + (j - miny) * extentx + i) &&
            x - (-1 * minx + (j - miny) * extentx + i) < minx + extentx - i &&
            lemma2dAccess(x - (-1 * minx + (j - miny) * extentx + i) + i, minx,
            1, extentx, j, miny, extentx, extenty) ==>
            acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), x)): Option[Pointer]))).int, write))
        invariant (forall x: Int ::
            { fPred(f, x, minx, extentx, j, miny, extenty) }
            minx <= x && x < i ==>
            acc(fPred(f, x, minx, extentx, j, miny, extenty), write)) 
      {
        fold acc(fPred(f, i, minx, extentx, j, miny, extenty), write)
        flatten1 := i
        i := i + 1
      }
      flatten := j
      j := j + 1
    }
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method conversePred(tid: Int, f: Option[Pointer], minx: Int, extentx: Int, miny: Int,
  extenty: Int)
  returns (res: Void)
  requires 0 < extentx
  requires 0 < extenty
  requires f !=
    ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
      (none1(): Option[Pointer]) :
      (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
  requires block_length(pointer_block(optGet2(f))) -
    pointer_offset(optGet2(f)) ==
    extentx * extenty
  requires (forall x: Int, y: Int ::
      { fPred(f, x, minx, extentx, y, miny, extenty) }
      minx <= x && x < minx + extentx && miny <= y && y < miny + extenty ==>
      acc(fPred(f, x, minx, extentx, y, miny, extenty), write))
  ensures 0 < extentx
  ensures 0 < extenty
  ensures f !=
    ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
      (none1(): Option[Pointer]) :
      (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
  ensures block_length(pointer_block(optGet2(f))) -
    pointer_offset(optGet2(f)) ==
    extentx * extenty
  ensures acc(int32Pred(f), write)
{
  {
    var exc: Ref
    var return: Void
    var j: Int
    var i: Int
    var flatten: Int
    var flatten1: Int
    var excbeforeloop: Ref
    var excbeforeloop1: Ref
    exc := null
    label LOOP
    excbeforeloop := exc
    j := miny
    while (j < miny + extenty)
      invariant exc == excbeforeloop
      invariant 0 < extentx
      invariant 0 < extenty
      invariant f !=
        ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
          (none1(): Option[Pointer]) :
          (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
      invariant block_length(pointer_block(optGet2(f))) -
        pointer_offset(optGet2(f)) ==
        extentx * extenty
      invariant miny <= j
      invariant j < miny + extenty + 1
      invariant (forall x_y: Int ::
          { ptrDeref(ptrAdd(optGet2(f), x_y)).int }
          0 <= x_y - (-1 * minx - extentx * miny + minx + extentx * miny) &&
          x_y - (-1 * minx - extentx * miny + minx + extentx * miny) <
          extentx * (j - miny) ==>
          acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), x_y)): Option[Pointer]))).int, write))
      invariant (forall x: Int, y: Int ::
          { fPred(f, x, minx, extentx, y, miny, extenty) }
          minx <= x && x < minx + extentx && j <= y && y < miny + extenty ==>
          acc(fPred(f, x, minx, extentx, y, miny, extenty), write)) 
    {
      label LOOP1
      excbeforeloop1 := exc
      i := minx
      while (i < minx + extentx)
        invariant exc == excbeforeloop1
        invariant 0 < extentx
        invariant 0 < extenty
        invariant f !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
        invariant block_length(pointer_block(optGet2(f))) -
          pointer_offset(optGet2(f)) ==
          extentx * extenty
        invariant minx <= i
        invariant i < minx + extentx + 1
        invariant (forall x: Int ::
            { ptrDeref(ptrAdd(optGet2(f), x)).int }
            0 <= x - (-1 * minx + (j - miny) * extentx + minx) &&
            x - (-1 * minx + (j - miny) * extentx + minx) < i - minx &&
            lemma2dAccess(x - (-1 * minx + (j - miny) * extentx + minx) +
            minx, minx, 1, extentx, j, miny, extentx, extenty) ==>
            acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), x)): Option[Pointer]))).int, write))
        invariant (forall x: Int ::
            { fPred(f, x, minx, extentx, j, miny, extenty) }
            i <= x && x < minx + extentx ==>
            acc(fPred(f, x, minx, extentx, j, miny, extenty), write)) 
      {
        unfold acc(fPred(f, i, minx, extentx, j, miny, extenty), write)
        flatten1 := i
        i := i + 1
      }
      flatten := j
      j := j + 1
    }
    fold acc(int32Pred(f), write)
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}