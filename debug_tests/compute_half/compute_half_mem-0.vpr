domain WellFoundedOrder[T]  {
  
  function bounded(v: T): Bool 
  
  function decreasing(v1: T, v2: T): Bool 
}

domain IntOrder  {
  
  axiom {
    (forall i: Int ::0 <= i == (bounded(i): Bool))
  }
  
  axiom {
    (forall i: Int ::(forall j: Int ::i < j == (decreasing(i, j): Bool)))
  }
}

domain Void  {
  
  function unit(): Void 
  
  axiom {
    (forall v: Void ::true ==> unit() == v)
  }
}

domain $domain$unknown1  {
  
  function unknown1(unknown42: Perm, unknown43: Perm): Perm interpretation "^"
}

domain $domain$to_int  {
  
  function to_int(to_int1: Perm): Int interpretation "to_int"
}

domain $domain$unknown18  {
  
  function unknown18(unknown44: Perm): Bool interpretation "is_int"
}

domain Block  {
  
  function block_length(b: Block): Int 
  
  function loc(b: Block, i: Int): Ref 
  
  function loc_inv_1(r: Ref): Block 
  
  function loc_inv_2(r: Ref): Int 
  
  axiom {
    (forall b: Block ::block_length(b) >= 0)
  }
  
  axiom {
    (forall b: Block, i: Int ::
      { loc(b, i) }
      loc_inv_1(loc(b, i)) == b && loc_inv_2(loc(b, i)) == i)
  }
}

domain Pointer  {
  
  function pointer_of(b: Block, offset: Int): Pointer 
  
  function pointer_block(p: Pointer): Block 
  
  function pointer_offset(p: Pointer): Int 
  
  axiom {
    (forall p: Pointer ::pointer_offset(p) >= 0 &&
      pointer_offset(p) < block_length(pointer_block(p)))
  }
  
  axiom {
    (forall b: Block, offset: Int ::
      { pointer_block(pointer_of(b, offset)), pointer_offset(pointer_of(b, offset)) }
      pointer_block(pointer_of(b, offset)) == b &&
      pointer_offset(pointer_of(b, offset)) == offset)
  }
}

domain Any  {
  
  
}

domain Option[T1]  {
  
  function none1(): Option[T1] 
  
  function some(x: T1): Option[T1] 
  
  function option_get(opt: Option[T1]): T1 
  
  axiom {
    (forall x: T1 ::
      { (some(x): Option[T1]) }
      (none1(): Option[T1]) != (some(x): Option[T1]))
  }
  
  axiom {
    (forall x: T1 ::
      { (some(x): Option[T1]) }
      (option_get((some(x): Option[T1])): T1) == x)
  }
  
  axiom {
    (forall opt: Option[T1] ::
      { (some((option_get(opt): T1)): Option[T1]) }
      (some((option_get(opt): T1)): Option[T1]) == opt)
  }
}

domain Nothing  {
  
  
}

field min: Int

field int: Int

field dim: Option[Pointer]

field ref: Ref

field dimensions: Int

field flags: Int

field extent: Int

field stride: Int

field host: Option[Pointer]

function mPi(): Perm
  decreases 
{
  314159265358979323846 * write / 100000000000000000000
}

function unknown2(x: Perm): Perm
  requires 0 * write / 1 <= x
  decreases 
  ensures result == unknown1(x, 5 * write / 10)


function unknown3(x: Perm): Perm
  decreases 
  ensures -1 * write / 1 <= result
  ensures result <= 1 * write / 1


function nondetfloat(): Perm
  decreases 


function unknown4(x: Perm): Perm
  requires -1 * write / 1 <= x
  requires x <= 1 * write / 1
  decreases 
  ensures (2 * write / 1 != 0 * write / 1 ?
      -mPi() * write / (2 * write / 1) :
      nondetfloat()) <=
    result
  ensures result <=
    (2 * write / 1 != 0 * write / 1 ?
      mPi() / (2 * write / 1) :
      nondetfloat())


function unknown5(x: Perm): Perm
  decreases 
  ensures -1 * write / 1 <= result
  ensures result <= 1 * write / 1


function unknown6(x: Perm): Perm
  requires -1 * write / 1 <= x
  requires x <= 1 * write / 1
  decreases 
  ensures 0 * write / 1 <= result
  ensures result <= mPi()


function unknown7(x: Perm): Perm
  decreases 
  ensures x == 0 * write / 1 ==> result == 0 * write / 1


function unknown8(x: Perm): Perm
  decreases 
  ensures (2 * write / 1 != 0 * write / 1 ?
      -mPi() * write / (2 * write / 1) :
      nondetfloat()) <=
    result
  ensures result <=
    (2 * write / 1 != 0 * write / 1 ?
      mPi() / (2 * write / 1) :
      nondetfloat())


function unknown9(x: Perm, y: Perm): Perm
  decreases 
  ensures -mPi() * write <= result
  ensures result <= mPi()


function unknown10(x: Perm): Perm
  decreases 
  ensures result == (unknown14(x) - unknown14(-x * write)) / 2


function unknown11(x: Perm): Perm
  decreases 
  ensures result == (unknown14(x) + unknown14(-x * write)) / 2


function unknown12(x: Perm): Perm
  decreases 
  ensures result ==
    (unknown14(x) - unknown14(-x * write)) /
    (unknown14(x) + unknown14(-x * write))


function unknown13(x: Perm, y: Perm): Perm
  decreases 
  ensures result == unknown16(x * x + y * y, 5 * write / 10)


function unknown14(x: Perm): Perm
  decreases 
  ensures result == unknown16(27182818284 * write / 10000000000, x)


function unknown15(x: Perm): Perm
  decreases 


function unknown16(x: Perm, y: Perm): Perm
  decreases 
  ensures result == unknown1(x, y)
  ensures 0 * write / 1 < x ==> 0 * write / 1 < result


function unknown17(x: Perm): Perm
  decreases 
  ensures result == to_int(x) * write / 1


function unknown19(x: Perm): Perm
  decreases 
  ensures result == (unknown18(x) ? x : (to_int(x) + 1) * write / 1)


function unknown20(x: Perm): Perm
  decreases 
  ensures !(x < 0 * write / 1 && unknown18(x - 5 * write / 10)) ==>
    result == to_int(x + 5 * write / 10) * write / 1
  ensures x < 0 * write / 1 && unknown18(x - 5 * write / 10) ==>
    result == x - 5 * write / 10


function unknown21(x: Perm): Perm
  requires 0 * write / 1 <= x
  decreases 
  ensures result == unknown35(x, 5 * write / 10)


function unknown22(x: Perm): Perm
  decreases 
  ensures -1 * write / 1 <= result
  ensures result <= 1 * write / 1


function unknown23(x: Perm): Perm
  requires -1 * write / 1 <= x
  requires x <= 1 * write / 1
  decreases 
  ensures (2 * write / 1 != 0 * write / 1 ?
      -mPi() * write / (2 * write / 1) :
      nondetfloat()) <=
    result
  ensures result <=
    (2 * write / 1 != 0 * write / 1 ?
      mPi() / (2 * write / 1) :
      nondetfloat())


function unknown24(x: Perm): Perm
  decreases 
  ensures -1 * write / 1 <= result
  ensures result <= 1 * write / 1


function unknown25(x: Perm): Perm
  requires -1 * write / 1 <= x
  requires x <= 1 * write / 1
  decreases 
  ensures 0 * write / 1 <= result
  ensures result <= mPi()


function unknown26(x: Perm): Perm
  decreases 
  ensures x == 0 * write / 1 ==> result == 0 * write / 1


function unknown27(x: Perm): Perm
  decreases 
  ensures (2 * write / 1 != 0 * write / 1 ?
      -mPi() * write / (2 * write / 1) :
      nondetfloat()) <=
    result
  ensures result <=
    (2 * write / 1 != 0 * write / 1 ?
      mPi() / (2 * write / 1) :
      nondetfloat())


function unknown28(x: Perm, y: Perm): Perm
  decreases 
  ensures -mPi() * write <= result
  ensures result <= mPi()


function unknown29(x: Perm): Perm
  decreases 


function unknown30(x: Perm): Perm
  decreases 
  ensures result == (unknown33(x) + unknown33(-x * write)) / 2


function unknown31(x: Perm): Perm
  decreases 
  ensures result ==
    (unknown33(x) - unknown33(-x * write)) /
    (unknown33(x) + unknown33(-x * write))


function unknown32(x: Perm, y: Perm): Perm
  decreases 
  ensures result == unknown35(x * x + y * y, 5 * write / 10)


function unknown33(x: Perm): Perm
  decreases 
  ensures result == unknown35(27182818284 * write / 10000000000, x)


function unknown34(x: Perm): Perm
  decreases 


function unknown35(x: Perm, y: Perm): Perm
  decreases 
  ensures result == unknown1(x, y)
  ensures 0 * write / 1 < x ==> 0 * write / 1 < result


function unknown36(x: Perm): Perm
  decreases 
  ensures result == to_int(x) * write / 1


function unknown37(x: Perm): Perm
  decreases 
  ensures result == (unknown18(x) ? x : (to_int(x) + 1) * write / 1)


function unknown38(x: Perm): Perm
  decreases 
  ensures !(x < 0 * write / 1 && unknown18(x - 5 * write / 10)) ==>
    result == to_int(x + 5 * write / 10) * write / 1
  ensures x < 0 * write / 1 && unknown18(x - 5 * write / 10) ==>
    result == x - 5 * write / 10


function ptrDeref(p: Pointer): Ref
  decreases 
{
  loc(pointer_block(p), pointer_offset(p))
}

function ptrAdd(p: Pointer, offset: Int): Pointer
  requires 0 <= pointer_offset(p) + offset
  requires pointer_offset(p) + offset < block_length(pointer_block(p))
  decreases 
{
  pointer_of(pointer_block(p), pointer_offset(p) + offset)
}

function anyAs(t: Any): Any
  decreases 


function asAny(t: Any): Any
  decreases 
  ensures anyAs(result) == t


function optGet(opt: Option[Any]): Any
  requires opt != (none1(): Option[Any])
  decreases 
  ensures (some(result): Option[Any]) == opt
{
  (option_get(opt): Any)
}

function optOrElse(opt: Option[Any], alt: Any): Any
  decreases 
  ensures opt == (none1(): Option[Any]) ==> result == alt
  ensures opt != (none1(): Option[Any]) ==> result == optGet(opt)
{
  (opt == (none1(): Option[Any]) ? alt : optGet(opt))
}

function max(x: Int, y: Int): Int
{
  (y < x ? x : y)
}

function min1(x: Int, y: Int): Int
{
  (y < x ? y : x)
}

function max1(x: Perm, y: Perm): Perm
{
  (y < x ? x : y)
}

function min2(x: Perm, y: Perm): Perm
{
  (y < x ? y : x)
}

function abs(x: Int): Int
{
  (0 <= x ? x : -x)
}

function abs1(x: Perm): Perm
{
  (0 * write / 1 <= x ? x : -x * write)
}

function hdiv(x: Int, y: Int): Int
{
  (y == 0 ? 0 : x / y)
}

function hmod(x: Int, y: Int): Int
{
  (y == 0 ? 0 : x % y)
}

function truncdiv(a: Int, b: Int): Int
  requires b != 0
  decreases 
{
  (let i ==
    (a / b) in
    (let i1 ==
      (a % b) in
      (0 <= a || i1 == 0 ? i : i + (0 < b ? 1 : -1))))
}

function truncmod(a: Int, b: Int): Int
  requires b != 0
  decreases 
{
  (let i ==
    (a % b) in
    (0 <= a || i == 0 ? i : i - (0 < b ? b : -b)))
}

function lemmaNonlinear(a: Int, b: Int, maxA: Int): Bool
  requires 0 <= a
  requires 0 < b
  requires a < maxA
  decreases b
  ensures a * b <= (maxA - 1) * b
  ensures result
{
  (1 < b ? lemmaNonlinear(a, b - 1, maxA) : true)
}

function lemma2dAccess(a: Int, minA: Int, strideA: Int, extentA: Int, b: Int,
  minB: Int, strideB: Int, extentB: Int): Bool
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires 0 < strideA
  requires extentA * strideA <= strideB
  decreases 
  ensures 0 <= (b - minB) * strideB
  ensures 0 <= (a - minA) * strideA + (b - minB) * strideB
  ensures (a - minA) * strideA + (b - minB) * strideB < strideB * extentB
  ensures result
{
  lemmaNonlinear(a - minA, strideA, extentA) &&
  lemmaNonlinear(b - minB, strideB, extentB)
}

function lemma3dAccess(a: Int, minA: Int, strideA: Int, extentA: Int, b: Int,
  minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int, extentC: Int): Bool
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires minC <= c
  requires c - minC < extentC
  requires 0 < strideA
  requires extentA * strideA <= strideB
  requires extentB * strideB <= strideC
  decreases 
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC <
    strideC * extentC
  ensures result
{
  lemma2dAccess(a, minA, strideA, extentA, b, minB, strideB, extentB) &&
  lemmaNonlinear(c - minC, strideC, extentC)
}

function lemma4dAccess(a: Int, minA: Int, strideA: Int, extentA: Int, b: Int,
  minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int, extentC: Int,
  d: Int, minD: Int, strideD: Int, extentD: Int): Bool
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires minC <= c
  requires c - minC < extentC
  requires minD <= d
  requires d - minD < extentD
  requires 0 < strideA
  requires extentA * strideA <= strideB
  requires extentB * strideB <= strideC
  requires extentC * strideC <= strideD
  decreases 
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC +
    (d - minD) * strideD
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC +
    (d - minD) * strideD <
    strideD * extentD
  ensures result
{
  lemma3dAccess(a, minA, strideA, extentA, b, minB, strideB, extentB, c, minC,
  strideC, extentC) &&
  lemmaNonlinear(d - minD, strideD, extentD)
}

function lemma5dAccess(a: Int, minA: Int, strideA: Int, extentA: Int, b: Int,
  minB: Int, strideB: Int, extentB: Int, c: Int, minC: Int, strideC: Int, extentC: Int,
  d: Int, minD: Int, strideD: Int, extentD: Int, e: Int, minE: Int, strideE: Int,
  extentE: Int): Bool
  requires minA <= a
  requires a - minA < extentA
  requires minB <= b
  requires b - minB < extentB
  requires minC <= c
  requires c - minC < extentC
  requires minD <= d
  requires d - minD < extentD
  requires minE <= e
  requires e - minE < extentE
  requires 0 < strideA
  requires extentA * strideA <= strideB
  requires extentB * strideB <= strideC
  requires extentC * strideC <= strideD
  requires extentD * strideD <= strideE
  decreases 
  ensures 0 <=
    (a - minA) * strideA + (b - minB) * strideB + (c - minC) * strideC +
    (d - minD) * strideD +
    (e - minE) * strideE
  ensures (a - minA) * strideA + (b - minB) * strideB +
    (c - minC) * strideC +
    (d - minD) * strideD +
    (e - minE) * strideE <
    strideE * extentE
  ensures result
{
  lemma4dAccess(a, minA, strideA, extentA, b, minB, strideB, extentB, c, minC,
  strideC, extentC, d, minD, strideD, extentD) &&
  lemmaNonlinear(e - minE, strideE, extentE)
}

function nothingAs(value: Nothing): Any
  decreases 


function nothingAs1(value: Nothing): Pointer
  decreases 


function optGet1(opt: Option[Nothing]): Nothing
  requires opt != (none1(): Option[Nothing])
  decreases 
  ensures (some(result): Option[Nothing]) == opt
{
  (option_get(opt): Nothing)
}

function optGet2(opt: Option[Pointer]): Pointer
  requires opt != (none1(): Option[Pointer])
  decreases 
  ensures (some(result): Option[Pointer]) == opt
{
  (option_get(opt): Pointer)
}

function pureOut(x: Int): Int


function scale(amount: Perm): Perm
  requires amount >= 0 * write
  decreases 
  ensures result >= 0 * write
{
  amount
}

function type(type1: Ref): Int
  decreases 
  ensures result >= 0
  ensures result <= 2
  ensures type1 == null ==> result == 0
  ensures type1 != null ==> result != 0


function subtype(subtype1: Int, subtype2: Int): Bool
  requires subtype1 >= 0
  requires subtype1 <= 2
  requires subtype2 >= 0
  requires subtype2 <= 2
  decreases 
{
  (subtype1 == 0 ==> true) &&
  ((subtype1 == 2 ==> subtype2 == 2) && (subtype1 == 1 ==> subtype2 == 1))
}

predicate fPred(data0: Option[Pointer], x: Int, xMin: Int, xExtent: Int, y: Int,
  yMin: Int, yExtent: Int) {
  xMin <= x && x < xMin + xExtent && yMin <= y && y < yMin + yExtent &&
  data0 !=
  ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
    (none1(): Option[Pointer]) :
    (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])) &&
  block_length(pointer_block(optGet2(data0))) -
  pointer_offset(optGet2(data0)) ==
  xExtent * yExtent &&
  lemma2dAccess(x, xMin, 1, xExtent, y, yMin, xExtent, yExtent) &&
  (let idx ==
    (x - xMin + (y - yMin) * xExtent) in
    acc(ptrDeref(optGet2((some(ptrAdd(optGet2(data0), idx)): Option[Pointer]))).int, write))
}

predicate int32Pred(data: Option[Pointer]) {
  data !=
  ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
    (none1(): Option[Pointer]) :
    (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])) &&
  (forall i: Int ::
    { ptrDeref(ptrAdd(optGet2(data), i)).int }
    0 <= i &&
    i <
    block_length(pointer_block(optGet2(data))) -
    pointer_offset(optGet2(data)) ==>
    acc(ptrDeref(optGet2((some(ptrAdd(optGet2(data), i)): Option[Pointer]))).int, write))
}

predicate outPred(data0: Option[Pointer], x: Int, xMin: Int, xExtent: Int, y: Int,
  yMin: Int, yExtent: Int) {
  xMin <= x && x < xMin + xExtent && yMin <= y && y < yMin + yExtent &&
  data0 !=
  ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
    (none1(): Option[Pointer]) :
    (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])) &&
  block_length(pointer_block(optGet2(data0))) -
  pointer_offset(optGet2(data0)) ==
  xExtent * yExtent &&
  lemma2dAccess(x, xMin, 1, xExtent, y, yMin, xExtent, yExtent) &&
  (let idx ==
    (x - xMin + (y - yMin) * xExtent) in
    acc(ptrDeref(optGet2((some(ptrAdd(optGet2(data0), idx)): Option[Pointer]))).int, write))
}

method unknown(tid: Int, expression: Bool) returns (res: Void)
  requires expression


method unknown39(tid: Int, format: Option[Pointer]) returns (res: Int)


method unknown40(tid: Int, size: Int) returns (res: Option[Pointer])


method unknown41(tid: Int, ptr: Option[Pointer]) returns (res: Void)


method toPred(tid: Int, f: Option[Pointer], minx: Int, extentx: Int, miny: Int,
  extenty: Int)
  returns (res: Void)
  requires 0 < extentx
  requires 0 < extenty
  requires f !=
    ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
      (none1(): Option[Pointer]) :
      (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
  requires block_length(pointer_block(optGet2(f))) -
    pointer_offset(optGet2(f)) ==
    extentx * extenty
  requires (forall i: Int ::
      { ptrDeref(ptrAdd(optGet2(f), i)).int }
      0 <= i &&
      i <
      block_length(pointer_block(optGet2(f))) - pointer_offset(optGet2(f)) ==>
      acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), i)): Option[Pointer]))).int, write))
  ensures 0 < extentx
  ensures 0 < extenty
  ensures f !=
    ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
      (none1(): Option[Pointer]) :
      (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
  ensures block_length(pointer_block(optGet2(f))) -
    pointer_offset(optGet2(f)) ==
    extentx * extenty
  ensures (forall x: Int, y: Int ::
      { fPred(f, x, minx, extentx, y, miny, extenty) }
      minx <= x && x < minx + extentx && miny <= y && y < miny + extenty ==>
      acc(fPred(f, x, minx, extentx, y, miny, extenty), write))
{
  {
    var exc: Ref
    var return: Void
    var j: Int
    var i: Int
    var flatten: Int
    var flatten1: Int
    var excbeforeloop: Ref
    var excbeforeloop1: Ref
    exc := null
    label LOOP
    excbeforeloop := exc
    j := miny
    while (j < miny + extenty)
      invariant exc == excbeforeloop
      invariant 0 < extentx
      invariant 0 < extenty
      invariant f !=
        ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
          (none1(): Option[Pointer]) :
          (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
      invariant block_length(pointer_block(optGet2(f))) -
        pointer_offset(optGet2(f)) ==
        extentx * extenty
      invariant miny <= j
      invariant j < miny + extenty + 1
      invariant (forall x_y: Int ::
          { ptrDeref(ptrAdd(optGet2(f), x_y)).int }
          0 <= x_y - (-1 * minx - extentx * miny + minx + extentx * j) &&
          x_y - (-1 * minx - extentx * miny + minx + extentx * j) <
          extentx * (miny + extenty - j) ==>
          acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), x_y)): Option[Pointer]))).int, write))
      invariant (forall x: Int, y: Int ::
          { fPred(f, x, minx, extentx, y, miny, extenty) }
          minx <= x && x < minx + extentx && miny <= y && y < j ==>
          acc(fPred(f, x, minx, extentx, y, miny, extenty), write)) 
    {
      label LOOP1
      excbeforeloop1 := exc
      i := minx
      while (i < minx + extentx)
        invariant exc == excbeforeloop1
        invariant 0 < extentx
        invariant 0 < extenty
        invariant f !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
        invariant block_length(pointer_block(optGet2(f))) -
          pointer_offset(optGet2(f)) ==
          extentx * extenty
        invariant minx <= i
        invariant i < minx + extentx + 1
        invariant (forall x: Int ::
            { ptrDeref(ptrAdd(optGet2(f), x)).int }
            0 <= x - (-1 * minx + (j - miny) * extentx + i) &&
            x - (-1 * minx + (j - miny) * extentx + i) < minx + extentx - i &&
            lemma2dAccess(x - (-1 * minx + (j - miny) * extentx + i) + i, minx,
            1, extentx, j, miny, extentx, extenty) ==>
            acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), x)): Option[Pointer]))).int, write))
        invariant (forall x: Int ::
            { fPred(f, x, minx, extentx, j, miny, extenty) }
            minx <= x && x < i ==>
            acc(fPred(f, x, minx, extentx, j, miny, extenty), write)) 
      {
        fold acc(fPred(f, i, minx, extentx, j, miny, extenty), write)
        flatten1 := i
        i := i + 1
      }
      flatten := j
      j := j + 1
    }
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method conversePred(tid: Int, f: Option[Pointer], minx: Int, extentx: Int, miny: Int,
  extenty: Int)
  returns (res: Void)
  requires 0 < extentx
  requires 0 < extenty
  requires f !=
    ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
      (none1(): Option[Pointer]) :
      (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
  requires block_length(pointer_block(optGet2(f))) -
    pointer_offset(optGet2(f)) ==
    extentx * extenty
  requires (forall x: Int, y: Int ::
      { fPred(f, x, minx, extentx, y, miny, extenty) }
      minx <= x && x < minx + extentx && miny <= y && y < miny + extenty ==>
      acc(fPred(f, x, minx, extentx, y, miny, extenty), write))
  ensures 0 < extentx
  ensures 0 < extenty
  ensures f !=
    ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
      (none1(): Option[Pointer]) :
      (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
  ensures block_length(pointer_block(optGet2(f))) -
    pointer_offset(optGet2(f)) ==
    extentx * extenty
  ensures acc(int32Pred(f), write)
{
  {
    var exc: Ref
    var return: Void
    var j: Int
    var i: Int
    var flatten: Int
    var flatten1: Int
    var excbeforeloop: Ref
    var excbeforeloop1: Ref
    exc := null
    label LOOP
    excbeforeloop := exc
    j := miny
    while (j < miny + extenty)
      invariant exc == excbeforeloop
      invariant 0 < extentx
      invariant 0 < extenty
      invariant f !=
        ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
          (none1(): Option[Pointer]) :
          (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
      invariant block_length(pointer_block(optGet2(f))) -
        pointer_offset(optGet2(f)) ==
        extentx * extenty
      invariant miny <= j
      invariant j < miny + extenty + 1
      invariant (forall x_y: Int ::
          { ptrDeref(ptrAdd(optGet2(f), x_y)).int }
          0 <= x_y - (-1 * minx - extentx * miny + minx + extentx * miny) &&
          x_y - (-1 * minx - extentx * miny + minx + extentx * miny) <
          extentx * (j - miny) ==>
          acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), x_y)): Option[Pointer]))).int, write))
      invariant (forall x: Int, y: Int ::
          { fPred(f, x, minx, extentx, y, miny, extenty) }
          minx <= x && x < minx + extentx && j <= y && y < miny + extenty ==>
          acc(fPred(f, x, minx, extentx, y, miny, extenty), write)) 
    {
      label LOOP1
      excbeforeloop1 := exc
      i := minx
      while (i < minx + extentx)
        invariant exc == excbeforeloop1
        invariant 0 < extentx
        invariant 0 < extenty
        invariant f !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
        invariant block_length(pointer_block(optGet2(f))) -
          pointer_offset(optGet2(f)) ==
          extentx * extenty
        invariant minx <= i
        invariant i < minx + extentx + 1
        invariant (forall x: Int ::
            { ptrDeref(ptrAdd(optGet2(f), x)).int }
            0 <= x - (-1 * minx + (j - miny) * extentx + minx) &&
            x - (-1 * minx + (j - miny) * extentx + minx) < i - minx &&
            lemma2dAccess(x - (-1 * minx + (j - miny) * extentx + minx) +
            minx, minx, 1, extentx, j, miny, extentx, extenty) ==>
            acc(ptrDeref(optGet2((some(ptrAdd(optGet2(f), x)): Option[Pointer]))).int, write))
        invariant (forall x: Int ::
            { fPred(f, x, minx, extentx, j, miny, extenty) }
            i <= x && x < minx + extentx ==>
            acc(fPred(f, x, minx, extentx, j, miny, extenty), write)) 
      {
        unfold acc(fPred(f, i, minx, extentx, j, miny, extenty), write)
        flatten1 := i
        i := i + 1
      }
      flatten := j
      j := j + 1
    }
    fold acc(int32Pred(f), write)
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}

method make_pointer_array_int(tid: Int, size: Int)
  returns (res: Option[Pointer])
  requires 0 <= size
  ensures res !=
    ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
      (none1(): Option[Pointer]) :
      (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer]))
  ensures block_length(pointer_block(optGet2(res))) == size
  ensures pointer_offset(optGet2(res)) == 0
  ensures (forall i: Int ::
      { ptrDeref(ptrAdd(optGet2(res), i)).int }
      0 <= i && i < size ==>
      acc(ptrDeref(optGet2((some(ptrAdd(optGet2(res), i)): Option[Pointer]))).int, write))


method computeHalfMem(tid: Int, outBuffer: Option[Pointer])
  returns (res: Int)
  requires (let buf ==
      (outBuffer) in
      (let p ==
        (1 * write / 2) in
        (let nDims ==
          (2) in
          buf !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])) &&
          block_length(pointer_block(optGet2(buf))) -
          pointer_offset(optGet2(buf)) ==
          1 &&
          acc(ptrDeref(optGet2(buf)).ref, p) &&
          acc(ptrDeref(ptrAdd(optGet2(buf), 0)).ref.dim, p) &&
          ptrDeref(ptrAdd(optGet2(buf), 0)).ref.dim !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])) &&
          block_length(pointer_block(optGet2(ptrDeref(ptrAdd(optGet2(buf), 0)).ref.dim))) -
          pointer_offset(optGet2(ptrDeref(ptrAdd(optGet2(buf), 0)).ref.dim)) ==
          nDims &&
          acc(ptrDeref(ptrAdd(optGet2(buf), 0)).ref.host, p) &&
          ptrDeref(ptrAdd(optGet2(buf), 0)).ref.host !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])))))
  requires (let dim1 ==
      (ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim) in
      (let p ==
        (1 * write / 2) in
        (let i ==
          (0) in
          acc(ptrDeref(optGet2((some(ptrAdd(optGet2(dim1), i)): Option[Pointer]))).ref, 1 *
          write /
          2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.min, 1 * write / 2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.stride, 1 * write / 2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.extent, 1 * write / 2))))
  requires (let dim1 ==
      (ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim) in
      (let p ==
        (1 * write / 2) in
        (let i ==
          (1) in
          acc(ptrDeref(optGet2((some(ptrAdd(optGet2(dim1), i)): Option[Pointer]))).ref, 1 *
          write /
          2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.min, 1 * write / 2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.stride, 1 * write / 2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.extent, 1 * write / 2))))
  requires block_length(pointer_block(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer),
    0)).ref.host))) -
    pointer_offset(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.host)) ==
    ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.extent *
    ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.stride
  requires ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    0)).ref.min ==
    0
  requires ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    0)).ref.extent ==
    100
  requires ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    0)).ref.stride ==
    1
  requires ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.min ==
    0
  requires ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.extent ==
    42
  requires ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.stride ==
    100
  requires (forall _0: Int, _1: Int ::
      { outPred(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.host, _0, 0, 100,
      _1, 0, 42) }
      0 <= _0 && _0 < 100 && 0 <= _1 && _1 < 42 ==>
      acc(outPred(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.host, _0, 0, 100,
      _1, 0, 42), write))
  ensures (let buf ==
      (outBuffer) in
      (let p ==
        (1 * write / 2) in
        (let nDims ==
          (2) in
          buf !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])) &&
          block_length(pointer_block(optGet2(buf))) -
          pointer_offset(optGet2(buf)) ==
          1 &&
          acc(ptrDeref(optGet2(buf)).ref, p) &&
          acc(ptrDeref(ptrAdd(optGet2(buf), 0)).ref.dim, p) &&
          ptrDeref(ptrAdd(optGet2(buf), 0)).ref.dim !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])) &&
          block_length(pointer_block(optGet2(ptrDeref(ptrAdd(optGet2(buf), 0)).ref.dim))) -
          pointer_offset(optGet2(ptrDeref(ptrAdd(optGet2(buf), 0)).ref.dim)) ==
          nDims &&
          acc(ptrDeref(ptrAdd(optGet2(buf), 0)).ref.host, p) &&
          ptrDeref(ptrAdd(optGet2(buf), 0)).ref.host !=
          ((none1(): Option[Nothing]) == (none1(): Option[Nothing]) ?
            (none1(): Option[Pointer]) :
            (some(nothingAs1(optGet1((none1(): Option[Nothing])))): Option[Pointer])))))
  ensures (let dim1 ==
      (ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim) in
      (let p ==
        (1 * write / 2) in
        (let i ==
          (0) in
          acc(ptrDeref(optGet2((some(ptrAdd(optGet2(dim1), i)): Option[Pointer]))).ref, 1 *
          write /
          2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.min, 1 * write / 2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.stride, 1 * write / 2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.extent, 1 * write / 2))))
  ensures (let dim1 ==
      (ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim) in
      (let p ==
        (1 * write / 2) in
        (let i ==
          (1) in
          acc(ptrDeref(optGet2((some(ptrAdd(optGet2(dim1), i)): Option[Pointer]))).ref, 1 *
          write /
          2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.min, 1 * write / 2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.stride, 1 * write / 2) &&
          acc(ptrDeref(ptrAdd(optGet2(dim1), i)).ref.extent, 1 * write / 2))))
  ensures block_length(pointer_block(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer),
    0)).ref.host))) -
    pointer_offset(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.host)) ==
    ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.extent *
    ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.stride
  ensures ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    0)).ref.min ==
    0
  ensures ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    0)).ref.extent ==
    100
  ensures ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    0)).ref.stride ==
    1
  ensures ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.min ==
    0
  ensures ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.extent ==
    42
  ensures ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.dim),
    1)).ref.stride ==
    100
  ensures (forall _0: Int, _1: Int ::
      { outPred(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.host, _0, 0, 100,
      _1, 0, 42) }
      0 <= _0 && _0 < 100 && 0 <= _1 && _1 < 42 ==>
      acc(outPred(ptrDeref(ptrAdd(optGet2(outBuffer), 0)).ref.host, _0, 0, 100,
      _1, 0, 42), write))
{
  {
    var exc: Ref
    var return: Int
    var out: Option[Pointer]
    var outMin0: Int
    var outExtent0: Int
    var outStride0: Int
    var outMin1: Int
    var outExtent1: Int
    var outStride1: Int
    var outS0Y: Int
    var f: Option[Pointer]
    var fS0X: Int
    var t2: Int
    var outS0X: Int
    var _1: Int
    var buf: Option[Pointer]
    var unknown45: Option[Pointer]
    var buf1: Option[Pointer]
    var d: Int
    var unknown46: Int
    var buf2: Option[Pointer]
    var d1: Int
    var unknown47: Int
    var buf3: Option[Pointer]
    var d2: Int
    var unknown48: Int
    var buf4: Option[Pointer]
    var d3: Int
    var unknown49: Int
    var buf5: Option[Pointer]
    var d4: Int
    var unknown50: Int
    var buf6: Option[Pointer]
    var d5: Int
    var unknown51: Int
    var tid1: Int
    var e: Bool
    var unknown52: Void
    var tid2: Int
    var e1: Bool
    var unknown53: Void
    var tid3: Int
    var e2: Bool
    var unknown54: Void
    var tid4: Int
    var e3: Bool
    var unknown55: Void
    var tid5: Int
    var e4: Bool
    var unknown56: Void
    var tid6: Int
    var e5: Bool
    var unknown57: Void
    var flatten: Option[Pointer]
    var flatten1: Option[Pointer]
    var flatten2: Int
    var flatten3: Int
    var flatten4: Int
    var flatten5: Int
    var flatten6: Int
    var flatten7: Int
    var flatten8: Int
    var flatten9: Int
    var flatten10: Int
    var flatten11: Int
    var flatten12: Int
    var flatten13: Int
    var flatten14: Int
    var flatten15: Int
    var flatten16: Int
    var flatten17: Int
    var flatten18: Int
    var flatten19: Int
    var flatten20: Bool
    var flatten21: Bool
    var flatten22: Bool
    var flatten23: Bool
    var flatten24: Bool
    var flatten25: Bool
    var flatten26: Int
    var flatten27: Int
    var res1: Option[Pointer]
    var flatten28: Option[Pointer]
    var res2: Void
    var flatten29: Int
    var flatten30: Int
    var flatten31: Int
    var res3: Void
    var flatten32: Int
    var flatten33: Int
    var flatten34: Int
    var flatten35: Int
    var flatten36: Int
    var flatten37: Int
    var flatten38: Int
    var flatten39: Int
    var excbeforeloop: Ref
    var excbeforeloop1: Ref
    var excbeforeloop2: Ref
    exc := null
    buf := outBuffer
    flatten := ptrDeref(ptrAdd(optGet2(buf), 0)).ref.host
    unknown45 := flatten
    goto UNKNOWN
    label UNKNOWN
    flatten1 := unknown45
    out := flatten1
    buf1 := outBuffer
    flatten2 := 0
    d := flatten2
    flatten3 := ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(buf1), 0)).ref.dim),
      d)).ref.min
    unknown46 := flatten3
    goto UNKNOWN1
    label UNKNOWN1
    flatten4 := unknown46
    outMin0 := flatten4
    buf2 := outBuffer
    flatten5 := 0
    d1 := flatten5
    flatten6 := ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(buf2), 0)).ref.dim),
      d1)).ref.extent
    unknown47 := flatten6
    goto UNKNOWN2
    label UNKNOWN2
    flatten7 := unknown47
    outExtent0 := flatten7
    buf3 := outBuffer
    flatten8 := 0
    d2 := flatten8
    flatten9 := ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(buf3), 0)).ref.dim),
      d2)).ref.stride
    unknown48 := flatten9
    goto UNKNOWN3
    label UNKNOWN3
    flatten10 := unknown48
    outStride0 := flatten10
    buf4 := outBuffer
    flatten11 := 1
    d3 := flatten11
    flatten12 := ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(buf4), 0)).ref.dim),
      d3)).ref.min
    unknown49 := flatten12
    goto UNKNOWN4
    label UNKNOWN4
    flatten13 := unknown49
    outMin1 := flatten13
    buf5 := outBuffer
    flatten14 := 1
    d4 := flatten14
    flatten15 := ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(buf5), 0)).ref.dim),
      d4)).ref.extent
    unknown50 := flatten15
    goto UNKNOWN5
    label UNKNOWN5
    flatten16 := unknown50
    outExtent1 := flatten16
    buf6 := outBuffer
    flatten17 := 1
    d5 := flatten17
    flatten18 := ptrDeref(ptrAdd(optGet2(ptrDeref(ptrAdd(optGet2(buf6), 0)).ref.dim),
      d5)).ref.stride
    unknown51 := flatten18
    goto UNKNOWN6
    label UNKNOWN6
    flatten19 := unknown51
    outStride1 := flatten19
    tid1 := tid
    flatten20 := outStride0 == 1
    e := flatten20
    label UNKNOWN7
    tid2 := tid
    flatten21 := outMin0 == 0
    e1 := flatten21
    label UNKNOWN8
    tid3 := tid
    flatten22 := outExtent0 == 100
    e2 := flatten22
    label UNKNOWN9
    tid4 := tid
    flatten23 := outStride1 == 100
    e3 := flatten23
    label UNKNOWN10
    tid5 := tid
    flatten24 := outMin1 == 0
    e4 := flatten24
    label UNKNOWN11
    tid6 := tid
    flatten25 := outExtent1 == 42
    e5 := flatten25
    label UNKNOWN12
    label LOOP
    excbeforeloop := exc
    flatten26 := 0
    outS0Y := flatten26
    while (outS0Y < 42)
      invariant exc == excbeforeloop
      invariant 0 <= outS0Y
      invariant outS0Y < 42 + 1
      invariant (forall outS0YForall: Int, outS0XForall: Int ::
          { outPred(out, outS0XForall, 0, 100, outS0YForall, 0, 42) }
          0 <= outS0YForall && outS0YForall < 42 && 0 <= outS0XForall &&
          outS0XForall < 100 ==>
          acc(outPred(out, outS0XForall, 0, 100, outS0YForall, 0, 42), write)) 
    {
      res1 := make_pointer_array_int(tid, 100)
      flatten28 := res1
      f := flatten28
      res2 := toPred(tid, f, 0, 100, outS0Y, 1)
      label LOOP1
      excbeforeloop1 := exc
      flatten29 := 0
      fS0X := flatten29
      while (fS0X < 100)
        invariant exc == excbeforeloop1
        invariant 0 <= fS0X
        invariant fS0X < 100 + 1
        invariant (forall fS0XForall: Int ::
            { fPred(f, fS0XForall, 0, 100, outS0Y, outS0Y, 1) }
            0 <= fS0XForall && fS0XForall < 100 ==>
            acc(fPred(f, fS0XForall, 0, 100, outS0Y, outS0Y, 1), write)) 
      {
        unfold acc(fPred(f, fS0X, 0, 100, outS0Y, outS0Y, 1), write)
        flatten31 := fS0X + outS0Y
        ptrDeref(ptrAdd(optGet2(f), fS0X)).int := flatten31
        fold acc(fPred(f, fS0X, 0, 100, outS0Y, outS0Y, 1), write)
        flatten30 := fS0X
        fS0X := fS0X + 1
      }
      res3 := conversePred(tid, f, 0, 100, outS0Y, 1)
      flatten32 := outS0Y * 100
      t2 := flatten32
      label LOOP2
      excbeforeloop2 := exc
      flatten33 := 0
      outS0X := flatten33
      while (outS0X < 100)
        invariant exc == excbeforeloop2
        invariant 0 <= outS0X
        invariant outS0X < 100 + 1
        invariant acc(int32Pred(f), scale(1 * write / 2) * write)
        invariant (forall outS0XForall: Int ::
            { outPred(out, outS0XForall, 0, 100, outS0Y, 0, 42) }
            0 <= outS0XForall && outS0XForall < 100 ==>
            acc(outPred(out, outS0XForall, 0, 100, outS0Y, 0, 42), write)) 
      {
        unfold acc(int32Pred(f), scale(1 * write / 2) * write)
        flatten35 := ptrDeref(ptrAdd(optGet2(f), outS0X)).int
        fold acc(int32Pred(f), scale(1 * write / 2) * write)
        flatten36 := flatten35
        _1 := flatten36
        unfold acc(outPred(out, outS0X, 0, 100, outS0Y, 0, 42), write)
        flatten37 := outS0X + t2
        flatten38 := _1 + 1
        ptrDeref(ptrAdd(optGet2(out), flatten37)).int := flatten38
        fold acc(outPred(out, outS0X, 0, 100, outS0Y, 0, 42), write)
        flatten34 := outS0X
        outS0X := outS0X + 1
      }
      flatten27 := outS0Y
      outS0Y := outS0Y + 1
    }
    flatten39 := 0
    return := flatten39
    goto END
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}