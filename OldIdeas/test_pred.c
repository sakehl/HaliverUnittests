
/* MACHINE GENERATED By Halide. */

#include <assert.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#ifndef HALIVER_GLOBALS
#define HALIVER_GLOBALS

struct halide_dimension_t {
    int32_t min, extent, stride;
    uint32_t flags;
};

inline void halide_unused(bool e){};

/*@
pure int max(int x, int y) = x > y ? x : y;

pure int min(int x, int y) = x > y ? y : x;

pure float max(float x, float y) = x > y ? x : y;

pure float min(float x, float y) = x > y ? y : x;

pure int abs(int x) = x >= 0 ? x : -x;

pure float abs(float x) = x >= 0 ? x : -x;

// Euclidean division is defined internally in VerCors
pure int hdiv(int x, int y) = y == 0 ? 0 : \euclidean_div(x, y);
pure int hmod(int x, int y) = y == 0 ? 0 : \euclidean_mod(x, y);
@*/

/*@
  requires y != 0;
  ensures \result == \euclidean_div(x, y);
@*/
inline int /*@ pure @*/ div_eucl(int x, int y)
{
    int q = x/y;
    int r = x%y;
    return r < 0 ? q + (y > 0 ? -1 : 1) : q;
}

/*@
  requires y != 0;
  ensures \result == \euclidean_mod(x, y);
@*/
inline int /*@ pure @*/ mod_eucl(int x, int y)
{
    int r = x%y;
    return (x >= 0 || r == 0) ? r : r + abs(y);
}

static inline int /*@ pure @*/ min(int x, int y) {return x < y ? x : y;}
static inline float /*@ pure @*/ fast_inverse_f32(float x) {return 1.0f/x;}

static inline float /*@ pure @*/ sqrt_f32(float x) {return sqrtf(x);}
static inline float /*@ pure @*/ sin_f32(float x) {return sinf(x);}
static inline float /*@ pure @*/ asin_f32(float x) {return asinf(x);}
static inline float /*@ pure @*/ cos_f32(float x) {return cosf(x);}
static inline float /*@ pure @*/ acos_f32(float x) {return acosf(x);}
static inline float /*@ pure @*/ tan_f32(float x) {return tanf(x);}
static inline float /*@ pure @*/ atan_f32(float x) {return atanf(x);}
static inline float /*@ pure @*/ atan2_f32(float x, float y) {return atan2f(x, y);}
static inline float /*@ pure @*/ sinh_f32(float x) {return sinhf(x);}
static inline float /*@ pure @*/ cosh_f32(float x) {return coshf(x);}
static inline float /*@ pure @*/ tanh_f32(float x) {return tanhf(x);}
static inline float /*@ pure @*/ hypot_f32(float x, float y) {return hypotf(x, y);}
static inline float /*@ pure @*/ exp_f32(float x) {return expf(x);}
static inline float /*@ pure @*/ log_f32(float x) {return logf(x);}
static inline float /*@ pure @*/ pow_f32(float x, float y) {return powf(x, y);}
static inline float /*@ pure @*/ floor_f32(float x) {return floorf(x);}
static inline float /*@ pure @*/ ceil_f32(float x) {return ceilf(x);}
static inline float /*@ pure @*/ round_f32(float x) {return roundf(x);}

static inline double /*@ pure @*/ sqrt_f64(double x) {return sqrt(x);}
static inline double /*@ pure @*/ sin_f64(double x) {return sin(x);}
static inline double /*@ pure @*/ asin_f64(double x) {return asin(x);}
static inline double /*@ pure @*/ cos_f64(double x) {return cos(x);}
static inline double /*@ pure @*/ acos_f64(double x) {return acos(x);}
static inline double /*@ pure @*/ tan_f64(double x) {return tan(x);}
static inline double /*@ pure @*/ atan_f64(double x) {return atan(x);}
static inline double /*@ pure @*/ atan2_f64(double x, double y) {return atan2(x, y);}
static inline double /*@ pure @*/ sinh_f64(double x) {return sinh(x);}
static inline double /*@ pure @*/ cosh_f64(double x) {return cosh(x);}
static inline double /*@ pure @*/ tanh_f64(double x) {return tanh(x);}
static inline double /*@ pure @*/ hypot_f64(double x, double y) {return hypot(x, y);}
static inline double /*@ pure @*/ exp_f64(double x) {return exp(x);}
static inline double /*@ pure @*/ log_f64(double x) {return log(x);}
static inline double /*@ pure @*/ pow_f64(double x, double y) {return pow(x, y);}
static inline double /*@ pure @*/ floor_f64(double x) {return floor(x);}
static inline double /*@ pure @*/ ceil_f64(double x) {return ceil(x);}
static inline double /*@ pure @*/ round_f64(double x) {return round(x);}

//inline float nan_f32() {return NAN;}
inline float nan_f32() {return 0.0f;}
/*@
inline resource dim_perm(struct halide_dimension_t *dim, rational p, int i) = 
 Perm(&dim[i], 1\2) **
 Perm(dim[i].min, 1\2) **
 Perm(dim[i].stride, 1\2) **
 Perm(dim[i].extent, 1\2)
 ;
 
 requires a >= 0;
 requires b > 0;
 requires a < max_a;
 ensures a*b <= (max_a-1)*b;
 ensures \result;
 decreases b;
pure bool lemma_nonlinear(int a, int b, int max_a);
 
 requires a-min_a >= 0 && a-min_a<extent_a;
 requires b-min_b >= 0 && b-min_b<extent_b;
 requires stride_a > 0;
 requires stride_b >= extent_a*stride_a;

 ensures 0 <= (b-min_b)*stride_b;
 ensures 0 <= (a-min_a)*stride_a + (b-min_b)*stride_b;
 ensures (a-min_a)*stride_a + (b-min_b)*stride_b < stride_b*extent_b;
 ensures \result;
 decreases;
pure bool lemma_2d_access(
 int a, int min_a, int stride_a, int extent_a,
 int b, int min_b, int stride_b, int extent_b);
@*/
#endif // HALIVER_GLOBALS

/*@
resource input_im_pred(
 int* data0
 , int _0, int _0_min, int _0_extent, int _1, int _1_min, int _1_extent) = 
 ( _0 >= _0_min && _0 < _0_min + _0_extent && 
  _1 >= _1_min && _1 < _1_min + _1_extent && 
  data0 != NULL && \pointer_length(data0) == _0_extent * _1_extent && 
  lemma_2d_access(_0, _0_min, 1, _0_extent, _1, _1_min, _0_extent, _1_extent)) ** 
  (\let int idx = (_0-_0_min)*1 + (_1-_1_min)*_0_extent;
   Perm(&data0[idx], write));

resource _int32_pred(int* data) = data != NULL ** (\forall* int i; 0<=i && i< \pointer_length(data); Perm(&data[i], write) );

resource out_pred(
 int* data0
 , int x, int x_min, int x_extent, int y, int y_min, int y_extent) = 
 ( x >= x_min && x < x_min + x_extent && 
  y >= y_min && y < y_min + y_extent && 
  data0 != NULL && \pointer_length(data0) == x_extent * y_extent && 
  lemma_2d_access(x, x_min, 1, x_extent, y, y_min, x_extent, y_extent)) ** 
  (\let int idx = (x-x_min)*1 + (y-y_min)*x_extent;
   Perm(&data0[idx], write));


@*/
#ifndef HALIDE_BUFFER_TYPE_INT32_T
#define HALIDE_BUFFER_TYPE_INT32_T
struct halide_buffer_int32_t {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    int32_t *host;
};

/*@ 
 requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ inline int32_t *_halide_buffer_get_host_int32_t(struct halide_buffer_int32_t *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_min_int32_t(struct halide_buffer_int32_t *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_max_int32_t(struct halide_buffer_int32_t *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_extent_int32_t(struct halide_buffer_int32_t *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** \pointer_length(buf) == 1 ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ inline int _halide_buffer_get_stride_int32_t(struct halide_buffer_int32_t *buf, int d) {
    return buf->dim[d].stride;
}

/*@
inline resource buffer_int32_t(struct halide_buffer_int32_t *buf, rational p, int n_dims) = 
 buf != NULL **
 \pointer_length(buf) == 1 **
 Perm(buf, p) **
 Perm(buf->dim, p) **
 buf->dim != NULL **
 \pointer_length(buf->dim) == n_dims **
 Perm(buf->host, p) **
 buf->host != NULL;
@*/
#endif //HALIDE_BUFFER_TYPE_INT32_T
//@ pure int pure_input(int x);
//@ pure int pure_out(int x);



#ifdef __cplusplus
extern "C" {
#endif

/*@
 context buffer_int32_t(_input_buffer, 1\2, 2);
 context dim_perm(_input_buffer->dim, 1\2, 0);
 context dim_perm(_input_buffer->dim, 1\2, 1);
 context \pointer_length(_input_buffer->host) == _input_buffer->dim[1].extent * _input_buffer->dim[1].stride;
 context _input_buffer->dim[0].min == 0 && _input_buffer->dim[0].extent == 42 && _input_buffer->dim[0].stride == 1;
 context _input_buffer->dim[1].min == 0 && _input_buffer->dim[1].extent == 100 && _input_buffer->dim[1].stride == 42;
 context [1\2]_int32_pred(_input_buffer->host);
 requires (\forall int _0, int _1; 0 <= _0 && _0 < 42 && 0 <= _1 && _1 < 100; (\unfolding [1\2]_int32_pred(_input_buffer->host) \in _input_buffer->host[_1*42 + _0] == pure_input(_1*42 + _0)));
 requires 
  (\unfolding [1\2]_int32_pred(_input_buffer->host) \in
  (\forall int _0, int _1; 0 <= _0 && _0 < 42 && 0 <= _1 && _1 < 100; _input_buffer->host[_1*42 + _0] == pure_input(_1*42 + _0))
  );
@*/
int par_par_mem(struct halide_buffer_int32_t *_input_buffer, struct halide_buffer_int32_t *_out_buffer) {
 int32_t* _input = _halide_buffer_get_host_int32_t(_input_buffer);
 // assert (\forall int _0, int _1; 0 <= _0 && _0 < 42 && 0 <= _1 && _1 < 100; (\unfolding [1\2]_int32_pred(_input) \in _input[_1*42 + _0] == pure_input(_1*42 + _0)));

 //@ assert  (\unfolding [1\2]_int32_pred(_input_buffer->host) \in (\forall int _0, int _1; 0 <= _0 && _0 < 42 && 0 <= _1 && _1 < 100; _input_buffer->host[_1*42 + _0] == pure_input(_1*42 + _0)));
 return 0;
}

#ifdef __cplusplus
}  // extern "C"
#endif

