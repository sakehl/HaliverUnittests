domain WellFoundedOrder[T]  {
  
  function bounded(v: T): Bool 
  
  function decreasing(v1: T, v2: T): Bool 
}

domain IntOrder  {
  
  axiom {
    (forall i: Int ::0 <= i == (bounded(i): Bool))
  }
  
  axiom {
    (forall i: Int ::(forall j: Int ::i < j == (decreasing(i, j): Bool)))
  }
}

domain Array  {
  
  function array_loc(a: Array, i: Int): Ref 
  
  function alen(a: Array): Int 
  
  function loc_inv_1(loc: Ref): Array 
  
  function loc_inv_2(loc: Ref): Int 
  
  axiom {
    (forall a: Array, i: Int ::
      { array_loc(a, i) }
      loc_inv_1(array_loc(a, i)) == a && loc_inv_2(array_loc(a, i)) == i)
  }
  
  axiom {
    (forall a: Array :: { alen(a) } alen(a) >= 0)
  }
}

domain Any  {
  
  
}

domain Option[T1]  {
  
  function none1(): Option[T1] 
  
  function some(x: T1): Option[T1] 
  
  function option_get(opt: Option[T1]): T1 
  
  axiom {
    (forall x: T1 ::
      { (some(x): Option[T1]) }
      (none1(): Option[T1]) != (some(x): Option[T1]))
  }
  
  axiom {
    (forall x: T1 ::
      { (some(x): Option[T1]) }
      (option_get((some(x): Option[T1])): T1) == x)
  }
  
  axiom {
    (forall opt: Option[T1] ::
      { (some((option_get(opt): T1)): Option[T1]) }
      (some((option_get(opt): T1)): Option[T1]) == opt)
  }
}

domain Void  {
  
  function unit(): Void 
  
  axiom {
    (forall v: Void ::true ==> unit() == v)
  }
}

field int: Int

function aloc(a: Array, i: Int): Ref
  requires 0 <= i
  requires i < alen(a)
  decreases 
  ensures loc_inv_1(result) == a
  ensures loc_inv_2(result) == i
{
  array_loc(a, i)
}

function anyAs(t: Any): Any
  decreases 


function asAny(t: Any): Any
  decreases 
  ensures anyAs(result) == t


function optGet(opt: Option[Any]): Any
  requires opt != (none1(): Option[Any])
  decreases 
  ensures (some(result): Option[Any]) == opt
{
  (option_get(opt): Any)
}

function optOrElse(opt: Option[Any], alt: Any): Any
  decreases 
  ensures opt == (none1(): Option[Any]) ==> result == alt
  ensures opt != (none1(): Option[Any]) ==> result == optGet(opt)
{
  (opt == (none1(): Option[Any]) ? alt : optGet(opt))
}

function optGet1(opt: Option[Array]): Array
  requires opt != (none1(): Option[Array])
  decreases 
  ensures (some(result): Option[Array]) == opt
{
  (option_get(opt): Array)
}

function scale(amount: Perm): Perm
  requires amount >= 0 * write
  decreases 
  ensures result >= 0 * write
{
  amount
}

function type(type1: Ref): Int
  decreases 
  ensures result >= 0
  ensures result <= 0
  ensures type1 == null ==> result == 0
  ensures type1 != null ==> result != 0


function subtype(subtype1: Int, subtype2: Int): Bool
  requires subtype1 >= 0
  requires subtype1 <= 0
  requires subtype2 >= 0
  requires subtype2 <= 0
  decreases 
{
  (subtype1 == 0 ==> true) && true
}

predicate int32Pred(data: Option[Array]) {
  data != (none1(): Option[Array]) &&
  (forall i: Int ::
    { aloc(optGet1(data), i) }
    0 <= i && i < alen(optGet1(data)) ==>
    acc(aloc(optGet1(data), i).int, write))
}

method main(tid: Int, data: Option[Array]) returns (res: Void)
  requires data != (none1(): Option[Array])
  requires acc(int32Pred(data), scale(1 * write / 2) * write)
  requires (forall i: Int ::
      { aloc(optGet1(data), i) }
      0 <= i && i < alen(optGet1(data)) ==>
      (unfolding acc(int32Pred(data), scale(1 * write / 2) * write) in
        aloc(optGet1(data), i).int == i))
  ensures data != (none1(): Option[Array])
  ensures acc(int32Pred(data), scale(1 * write / 2) * write)
  ensures (forall i: Int ::
      { aloc(optGet1(data), i) }
      0 <= i && i < alen(optGet1(data)) ==>
      (unfolding acc(int32Pred(data), scale(1 * write / 2) * write) in
        aloc(optGet1(data), i).int == i))
{
  {
    var exc: Ref
    var return: Void
    var sum: Int
    var i: Int
    var flatten: Int
    var flatten1: Int
    var flatten2: Int
    var flatten3: Int
    var excbeforeloop: Ref
    exc := null
    flatten := 0
    sum := flatten
    label LOOP
    excbeforeloop := exc
    flatten1 := 0
    i := flatten1
    while (i < alen(optGet1(data)))
      invariant exc == excbeforeloop
      invariant data != (none1(): Option[Array])
      invariant 0 <= i
      invariant i < alen(optGet1(data)) + 1
      invariant acc(int32Pred(data), scale(1 * write / 2) * write)
      invariant (forall i1: Int ::
          { aloc(optGet1(data), i1) }
          0 <= i1 && i1 < alen(optGet1(data)) ==>
          (unfolding acc(int32Pred(data), scale(1 * write / 2) * write) in
            aloc(optGet1(data), i1).int == i1)) 
    {
      unfold acc(int32Pred(data), scale(1 * write / 2) * write)
      flatten3 := sum + aloc(optGet1(data), i).int
      sum := flatten3
      fold acc(int32Pred(data), scale(1 * write / 2) * write)
      flatten2 := i
      i := i + 1
    }
    label END
    res := return
    label BUBBLE
    assert exc == null
  }
}